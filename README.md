# Установка и запуск

* Склонировать, установить зависимости
* Запуск линтера ``` yarn run lint ```
* Запуск в режиме разработки ``` yarn run dev ```, приложение доступно по адресу http://localhost:5555
* Запуск сборки ``` yarn run build ```
* Демо на github pages: [ссылка](https://2gnc.github.io/algo-workshop/index.html)


## Генератор событий

### Предпосылки

Исхожу из того, что методам на вход подаются корректные данные (метод - строка, колбэк - функция). 

Функции из подписки вызываю в том порядке, в котрором они были добавлены.

Возможную асинхронность игнорирую: для вызова последующей функции не жду окончания выполнения предыдущей.


### Описание решения

Событие - объект с двумя полями: тип и имя.

В качестве структуры данных для хранения подписок использую объект this.events, внутри которого в качестве ключа - имя события, а в качестве значения - массив. 

__on__: проверяю, есть ли ключ соответсвующий переданному событию, если нет - создаю. Затем проверяю, есть ли обработчик, если нет - добавляю. 

__off__ проверяю, есть ли в массиве передаваемый хэндлер, если есть - удаляю его методом splice.

#### Сложность

on: O(1)  

off: O(1) 

emit: O(N)

для проверки с помощью вспомогательной функции сгенерировала колбэки, подпсалась на них, и замеряла время выполнения emit()

## Саджестер

### Условия
* на выходе не больше 10 вариантов
* регистр не учитывается

### Предпосылки
Исхожу из следующих предположений: 
* данные корректные (инпут - строка длинны 3 и более, без случайных пробелов, data - массив строк)
* минимальное количество символов для поиска - 3

### Реализация
Это было одно из самых интересных для меня заданий. Я сделала 3 варианта. В качестве "большого массива" взяла файл с улицами Москвы и дополнила его улицами Нью-Йорка (их продублровала, для объема). Поиск возможен и по английским и по русским улицам, от регистра текста улици или инпута не зависит. 

Кажется, я не до конца поняла, как правильно считать асимптотическую сложность.

**1 вариат - влоб**

Это первое, что сходу пришло в голову - поиск регулярными выражениями. См ``` src/Suggestr.js -  vlob(input)```. Среднее время выполнения на моем компьютере - 2.5 - 3.0. Сложность O(N).  

**2 вариат - с предварительной обработкой массива**

Дальше я проверила предположение, что с предварительной обработкой массива - источника дело пойдет быстрее. В качестве предварительной обработки я разбила исходный массив на подмассивы по количеству символов в строке и при поиске исключила те, которые короче инпута.
``` src/Suggestr.js -  dataSort(), suggestV2(input)``` 

Здесь среднее время 0.7 - 1.1. Сложность... тоже O(N)? 

Наверняка, в этом направлении можно сделать что-то поинтересней, но на момент сдачи работы альтернативного рабочего решения у меня нет.

**3 вариат - алгоритм Бойера - Мура**

``` src/Suggestr.js - simpleBoyerMur(input),  comparer(substr, needle)```

Дальше мне стало интересно, а какие вообще существуют алгоритмы поиска подстроки. Вариант с суффиксным деревом реализовывать не стала (не смогла толком разобраться, как это дерево построить), а реализовала упрощенный аглоритм Бойера - Мура. И он... в среднем в 20 раз медленнее, чем вариант №2. Я, конечно, еще подумаю, как улучшить мой код, но не думаю, что добьюсь существенного улучшения производительности.

Тут сложность O(N+M).


### Выводы и открытые вопросы

Увлекательный мир алгоритмов, что тут скажешь - это и правда оказалось интересно - пошла читать Кормена. 

А вот что касается именно поиска подстроки для названий улиц... Как обычно поступают в боевых условиях? Могу предположить, что поиск происходит на сервере, не заливать же на клиента всю базу улиц. Также, наверное, где-то хранятся частые запросы и саджесты для них. Наверняка база улиц как то предварительно оптимизирована. Как? Какой вариант с точки зрения алгоритмов все-таки верный? 